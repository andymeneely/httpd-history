package edu.rit.se.history.httpd.intro;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 
 */

/**
 * @author harsha
 * 
 */
public class VulnerabilityIntro {

	/**
	 * Call the getPatch method to find the commit hash in git that fixed the given
	 * vulnerability. this will be input to git bisect as a good version
	 * @param args
	 */
	public static void main(String[] args) {
		String commitHash = null;
		try {
			commitHash = getPatch(args[0], args[1]);
			System.out.println("Commit that Fixed the vulnerability is::"
					+ commitHash);
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Each commit to git has a unique commit message. This is the basis on which 
	 * we search for. Searching for the patch involves parsing the entire file,
	 * which might affect performance. Hence the use of the commit message, which
	 * is unique to each commit
	 * @param fileName
	 * @return commitHash the commit that fixed the vulnerability for the given cve
	 * @throws InterruptedException
	 * @throws IOException 
	 */
	public static String getPatch(String fileName, String message) throws InterruptedException, IOException {
		Process process = null;
		String tempStr = null;
		String commitHash = null;
		try {
			Runtime runtime = Runtime.getRuntime();
			process = runtime
					.exec("git log --follow --pretty=format:\"%H/%s\" "
							.concat(fileName));

			BufferedReader stdInput = new BufferedReader(new InputStreamReader(
					process.getInputStream()));
			while ((tempStr = stdInput.readLine()) != null) {
				//System.out.println(tempStr.concat("\n"));
				if (tempStr.contains(message)) {
					System.out.println(tempStr);
					String[] commit = tempStr.split("/");
					commitHash = commit[0];
				}
			}
			stdInput.close();
		} catch (IOException e) {
			e.printStackTrace();
		} 
		return commitHash;
	}

}
